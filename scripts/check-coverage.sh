#!/bin/bash

set -e

# check-coverage.sh <path to coverage file> <import path of this package> <regex of file paths to ignore>
#
# Parses the coverage profile and prints every source file section that was reported as uncovered, skipping
# any section that contains a comment starting with "// COVERAGE" (our convention for denoting known gaps in
# coverage that should be ignored). It returns exit code 1 if any were found, 0 if not.
#
# The coverage profile generated by Go tests (in "set" coverage mode) contains a series of lines in this format:
#   <package path>/<file path>:<start line>.<start col>,<end line>.<end col>,<number of statements>,<pass>
# The <pass> field is 1 if this span of code was covered. There may be any number of lines for the same code
# span where <pass> is 0, but as long as there is also one where <pass> is 1, that span can be ignored.

COVERAGE_FILE=$1
PACKAGE_PATH=$2
IGNORE_FILES_PATTERN=$3

PACKAGE_PREFIX="$PACKAGE_PATH/"

function extract_failed_spans() {
  last_failed_span=""
  sort | uniq | \
    while read -r line; do
      span_desc=${line%% *}
      if [[ "${line}" =~ 0$ ]]; then
        if [[ -n "${last_failed_span}" ]]; then
          echo "${last_failed_span}"
        fi
        last_failed_span="${span_desc}"
      else
        last_failed_span=""
      fi
    done
  if [[ -n "${last_failed_span}" ]]; then
    echo "${last_failed_span}"
  fi
}

missed_some=""

extract_failed_spans < "${COVERAGE_FILE}" |
  while read -r span; do
    filepath="${span%%:*}"
    filepath="${filepath#$PACKAGE_PREFIX}"

    if [[ "${filepath}" =~ $IGNORE_FILES_PATTERN ]]; then
      continue
    fi

    line_start=$(echo "${span}" | sed -e 's/.*:\([0-9]*\)\..*/\1/')
    line_end=$(echo "${span}" | sed -e 's/.*,\([0-9]*\).*/\1/')
    lines=$(sed < "${filepath}" -n -e "${line_start},${line_end} p")

    if ! echo "${lines}" | grep "// COVERAGE:" >/dev/null; then
      if [[ -z "${missed_some}" ]]; then
        echo
        echo "The following code spans were not covered in tests, and did not contain a \"// COVERAGE:\" comment:"
        missed_some=1
      fi
      echo
      echo ">>> $filepath $line_start-$line_end"
      echo "$lines"
    fi
  done

if [[ -n "${missed_some}" ]]; then
  exit 1
fi
